## @ingroup Components-Energy-Distributors
# Cryogenic_Lead.py
#
# Created:  Feb 2020, K. Hamilton - Through New Zealand Ministry of Business Innovation and Employment Research Contract RTVU2004 
# Modified: Nov 2021, S. Claridge

# ----------------------------------------------------------------------
#  Imports
# ----------------------------------------------------------------------

# suave imports
import SUAVE

from SUAVE.Components.Energy.Energy_Component import Energy_Component
from SUAVE.Methods.Costs.Correlations.Industrial_Costs.compute_industrial_costs import compute_industrial_costs
from SUAVE.Methods.Cryo.Leads.lead_calculations import Q_min
from SUAVE.Methods.Cryo.Leads.lead_calculations import calc_current 
from SUAVE.Methods.Cryo.Leads.lead_calculations import LARatio
from SUAVE.Attributes.Solids.Solid import Solid
from scipy import integrate
from scipy import interpolate
from scipy.misc import derivative
import numpy as np
# ----------------------------------------------------------------------
#  Cryogenic Lead Class
# ----------------------------------------------------------------------

## @ingroup Components-Energy-Distributors
class Cryogenic_Lead(Energy_Component):
    
    def __defaults__(self):
        """ This sets the default values.
    
            Assumptions:
            Cryogenic Leads only operate at their optimum current, or at zero current.
    
            Source:
            Current Lead Optimization for Cryogenic Operation at Intermediate Temperatures - Broomberg
    
            Inputs:
            None
    
            Outputs:
            None
    
            Properties Used:
            None
            """         
        self.cold_temp          = 0.0    # [K]
        self.hot_temp           = 0.0    # [K]
        self.current            = 0.0       # [A]
        self.length             = 0.0    # [m]
        self.material           = None
    
        self.cross_section      = 0.0    # [m2]
        self.optimum_current    = 0.0         # [A]
        self.minimum_Q          = 0.0         # [W]
        self.unpowered_Q        = 0.0         # [W]

    def initialize_material_lead(self, conditions):
        """
        Defines an optimum material lead for supplying current to a cryogenic environment given the operating conditions and material properties.
        
        Assumptions:
        None
        
        Inputs:
            lead.
                cold_temp           [K]
                hot_temp            [K]
                current             [A]
                length              [m]

        Outputs:      
            lead.     
                mass                [kg]
                cross_section       [m]
                optimum_current     [A]
                minimum_Q           [W]
        """

        # Unpack properties
        cold_temp   = self.cold_temp
        hot_temp    = self.hot_temp 
        current     = self.current  
        length      = self.length   
        material    = self.material
        

        # Find the heat generated by the optimum lead
        minimum_Q = Q_min(material, cold_temp, hot_temp, current)[0]

        # # Calculate the optimum length to cross-sectional area ratio
        la_ratio = LARatio(material, cold_temp, hot_temp, current, minimum_Q)

        # Calculate the cross-sectional area
        cs_area = length/la_ratio
        # Apply the material density to calculate the mass
        mass = cs_area*length*material.density

        # Pack up results
        self.mass_properties.mass   = mass
        self.cross_section          = cs_area
        self.optimum_current        = current
        self.minimum_Q              = minimum_Q

        # find the heat conducted into the cryogenic environment if no current is flowing
        unpowered_Q             = self.Q_unpowered(conditions)

        # Pack up unpowered lead
        self.unpowered_Q        = unpowered_Q[0]

    def Q_unpowered(self, conditions):
        # Estimates the heat flow into the cryogenic environment if no current is supplied to the lead.

        # unpack properties
        hot_temp        = self.hot_temp     
        cold_temp       = self.cold_temp    
        cross_section   = self.cross_section
        length          = self.length
        material        = self.material

        # Integrate the thermal conductivity across the relevant temperature range.
        integral = integrate.quad(lambda T: material.thermal_conductivity(T), cold_temp, hot_temp)

        # Apply the conductivity to estimate the heat flow
        Q       = integral[0] * cross_section / length

        # Electrical power is obviously zero if no current is flowing
        power   = 0.0

        return [Q, power]

    def Q_offdesign(self, conditions):
        # Estimates the heat flow into the cryogenic environment when a current other than the current the lead was optimised for is flowing. Assumes the temperature difference remains constant.
        current = conditions.energies.rotor_current

        #print("current = ", current)

        
        values = [calc_current(self,x) for x in current]

        #print("values = ", values)
        
    
        return np.array(values)

